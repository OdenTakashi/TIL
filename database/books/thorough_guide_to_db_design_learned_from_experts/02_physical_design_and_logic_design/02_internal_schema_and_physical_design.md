## 内部スキーマと物理設計
### 物理設計のステップ
1. テーブル定義
2. index定義
3. ハードウェアのサイジング
  - データの正規化による整合性とパフォーマンスには強いトレードオフの関係がある。
  - システムで利用するデータ量
  - システムが利用するデータの増加量に対する策
    - 余裕を持ったサイジング
    - オンプレの場合、ストレージ追加を行いやすくする構成にする
    - クラウド利用の場合、都度追加していく
  - パフォーマンスのサイジング
    - 性能要件: どれだけ速く、どれだけ多いか
      - 応答時間
      - TPS(Transaction Per Second)
    - リソース使用量の基礎数値: どの程度の処理を行うとどの程度のハードウェアリソースを消費するか
      - 計測方法は以下: 完璧な計測はできないため、拡張性の高い構成にする必要がある。
        - 類似システムから流用
        - プロトタイプによる計測
4. ストレージの冗長構成決定
  - データベースを保持する媒体、HDDよりもSSDが利用される -> 読み書きは早いが、コストが高い
  - データを失うことは許されないため、ストレージを冗長にして耐障害性を持つようにする。
    - RAID(Redundant Array of Independent Disk)
      - 元の目的は安価なディスクでシステムを保持すること
      - 複数のディスクに同じデータを書き込み冗長化させる
      - 性能向上: 分散してデータを保持、I/Oの分散
      - RAIDにはレベルが存在する。
        - RAID0(ストライピング): ビジネス上は良くない。
          データを複数のディスクに分散、冗長性はない。<br>
          ディスク1: データ1, データ3, データ5, データ7<br>
          ディスク2: データ2, データ4, データ6, データ8
        - RAID1(ミラーリング)
          2本のディスクに同じデータを持つ、冗長性はあるが、分散しないため性能は1本の場合と変わらない<br>
          ディスク1: データ1, データ2, データ3<br>
          ディスク1: データ1, データ2, データ3
        - RAID5(パリティ分散)
          最低3本のディスクから構成。データAをA1, A2, A3のように分割して持ち、加えてパリティ情報を持ちます。書き込み時には3つのディスクに処理が分散されるため性能が向上します。<br>
          また、データA1が失われても他の3つの情報から復元可能なので冗長性がある。<br>
          ディスク1: データA1<br>
          ディスク2: データA2<br>
          ディスク3: データA3<br>
          ディスク4: パリティA
        - RAID10: 望ましい。
          RAID1 + RAID0<br>
          ストライプでデータを持って、ミラーする
5. ファイルの物理配置決定
  データベースのファイルをどのディスクに置くか。<br>
  格納する対象ファイルは以下<br>
   - データファイル -> 意識するファイル, テーブルデータ
   - インデックスファイル -> 意識するファイル, そこに付与されているインデックスファイル
  以下はDBA(DB Administrator)のみが意識する
   - システムファイル
   - 一時ファイル
   - ログファイル
  
  データファイル
    ユーザーがDBに隠そうするデータを保持するためのファイル、アプリからのSQLはこのファイルに参照、更新を行う。<br>
    アプリからはファイルは見えず、見えるのはテーブルという論理的単位のみ

  インデックスファイル
    テーブルファイルとは別ファイル、開発者はテーブルに対してSQLを投げるがインデックスに対してアクセスはしない<br>
    インデックスを利用するかどうかはユーザーは判断せず、DBMSが判断する。
  
  システムファイル
    DBMS内部管理用に利用されるデータを格納する。アプリやユーザーのアクセスは基本的にない
  
  一時ファイル
    データの絞り込みなどのサブクエリを展開したデータや、ソートデータなどの使用したら削除されるデータを格納、継続的なデータ増加はない。

  ログファイル
    DBMSはデータ更新の際に、ログファイルに変更文を溜めた後に非同期で更新を行なっている。
    REDOログ、トランザクションログ..

  注意点: データベースを論理レベルで分離すればI/Oが分散されるわけではない。
    分けた上で、どのように、どのくらいの数のディスクに分割していくかで性能、容量が変わってくる。
